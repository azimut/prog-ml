## Parsing MNIST

```futhark
def parse_field (raw: []u8) : i64 =
  (i64.u8 raw[0] << 24) + (i64.u8 raw[1] << 16) + (i64.u8 raw[2] << 8) + (i64.u8 raw[3] << 0)

entry parse_header (raw: []u8) : (i64, i64, i64, i64) =
  (parse_field raw[0:4], parse_field raw[4:8], parse_field raw[8:12], parse_field raw[12:16])

def parse_labels (raw: []u8) : []f64 =
  map (f64.u8) raw[8:]

def get_nth_label (n: i64) (labels: []f64) : f64 =
  head (drop n labels)

def parse_images (xs: []u8) : [][]f64 =
  let (_magic, n_imgs, n_rows, n_cols) = parse_header xs
  let n_pixels = n_rows * n_cols
  let pixels = map (\x -> f64.u8 x / 255) xs[16:]
  in unflatten (pixels :> [n_imgs * n_pixels]f64)

def get_nth_image (n: i64) (pixels: [][]f64) : [][]f64 =
  unflatten (pixels[n] :> [28 * 28]f64)
```

```
> :img get_nth_image 23 (parse_images ($loadbytes "data/t10k-images-idx3-ubyte"))
```

![](media/06a.mnist-img/ab87f15e1c0c61c04499750f54e3a5a9-img.png)


```
> get_nth_label 23 (parse_labels ($loadbytes "data/t10k-labels-idx1-ubyte"))
```

```
5.0f64
```


## Training

```futhark
import "utils"

def sigmoid [n] [m] (A: [n][m]f64) : [n][m]f64 =
  matunary ((0 -) >-> f64.exp >-> (1 +) >-> (1 /)) A

def forward [n] [m] (feats: [n][m]f64) (weights: [m][1]f64) : [n][1]f64 =
  sigmoid (matmul feats weights)

def gradient [n] [m] (feats: [n][m]f64) (truths: [n][1]f64) (weights: [m][1]f64) : [m][1]f64 =
  matsub (forward feats weights) truths
  |> matmul (transpose feats)
  |> matunary (/ (f64.i64 n))

def init_weights (m: i64) : [m][1]f64 =
  unflatten ((replicate m 0.0) :> [m * 1]f64)

def train_step [n] [m] (features: [n][m]f64) (truths: [n][1]f64) (lrate: f64) (weights: [m][1]f64) : [m][1]f64 =
  matsub weights (matsmul (gradient features truths weights) lrate)

def train [n] [m] (features: [n][m]f64) (truths: [n][1]f64) (iterations: i64) (lrate: f64) : [m][1]f64 =
  loop weights = init_weights m
  for _i < iterations do
    train_step features truths lrate weights
```

We are going to only look to identify 5's

```futhark
def encode_labels [n] (labels: [n]f64) : [n][1]f64 =
  -- see: https://futhark.readthedocs.io/en/latest/error-index.html#nonconstructive-entry
  let labels = labels :> [n * 1]f64
  let is_five = map (\label -> if label > 4.9 && label < 5.1 then 1 else 0) labels
  in unflatten is_five

def add_bias [n] [m] (images: [n][m]f64) : [n][1 + m]f64 =
  ([replicate n 1.0] ++ (transpose images)) |> transpose
```

## Loss

```futhark
def loss [n] [m] (feats: [n][m]f64) (truths: [n][1]f64) (weights: [m][1]f64) : f64 =
  let y_hat = forward feats weights
  let first_term = matop (*) truths (matunary (f64.log) y_hat)
  let second_term = matop (*) (matunary (1 -) truths) (matunary (f64.log) y_hat)
  in matadd first_term second_term |> flatten |> average |> f64.neg

def current_loss (features: [][]f64) (labels: [][1]f64) : f64 =
  let weights = train features labels 100 1e-5
  in loss features labels weights
```

```
> current_loss (add_bias (parse_images ($loadbytes "data/train-images-idx3-ubyte"))) (encode_labels (parse_labels ($loadbytes "data/train-labels-idx1-ubyte")))
```

```
0.7005802166508345f64
```


## Picture of final weights

```futhark
def draw_weights (features: [][]f64) (labels: [][1]f64) : [][]f64 =
  let weights = train features labels 100 1e-5
  let fweights = flatten weights
  let min_weight = reduce (f64.min) 1e10 fweights[1:]
  let max_weight = reduce (f64.max) (-1e10) fweights[1:]
  in unflatten ((map ((interpolate min_weight max_weight 0 1) >-> (1 -)) fweights[1:]) :> [28 * 28]f64)
```

```
> :img draw_weights (add_bias (parse_images ($loadbytes "data/t10k-images-idx3-ubyte"))) (encode_labels (parse_labels ($loadbytes "data/t10k-labels-idx1-ubyte")))
```

![](media/06a.mnist-img/9571959e38fd52ced5cde20f7c6dcfff-img.png)


## Animation of the whole learning process

```futhark
def animate_weights (features: [][]f64) (labels: [][1]f64) (lrate: f64) (weights: [][1]f64) : ([][]f64, [][1]f64) =
  let fweights = flatten weights
  let min_weight = -2.4176444437863176e-4f64
  let max_weight = 2.710347504252503e-6f64
  let image = unflatten ((map ((interpolate min_weight max_weight 0 1) >-> (1 -)) fweights[1:]) :> [28 * 28]f64)
  in (image, train_step features labels lrate weights)
```

```
> :video (animate_weights (add_bias (parse_images ($loadbytes "data/t10k-images-idx3-ubyte"))) (encode_labels (parse_labels ($loadbytes "data/t10k-labels-idx1-ubyte"))) 1e-5, init_weights 785i64, 100i64);
fps: 24
format: gif
```

![](media/06a.mnist-img/da8862862247a5388b6e31152c965feb-video.gif)


## Measure model against test data

```futhark
def classify [n] [m] (feats: [n][m]f64) (weights: [m][1]f64) : [n][1]f64 =
  matunary (f64.round) (forward feats weights)

def predictability [m]
                   (train_features: [][m]f64)
                   (train_labels: [][1]f64)
                   (test_features: [][m]f64)
                   (test_labels: [][1]f64) : f64 =
  let weights = train train_features train_labels 100 1e-5
  let predictions = classify test_features weights
  let ncorrect = f64.sum (flatten (matop (\a b -> if (f64.abs (a - b)) < 0.1 then 1 else 0) predictions test_labels))
  in ncorrect * 100 / f64.i64 (length (flatten test_labels))
```

```
> predictability (add_bias (parse_images ($loadbytes "data/train-images-idx3-ubyte"))) (encode_labels (parse_labels ($loadbytes "data/train-labels-idx1-ubyte"))) (add_bias (parse_images ($loadbytes "data/t10k-images-idx3-ubyte"))) (encode_labels (parse_labels ($loadbytes "data/t10k-labels-idx1-ubyte")))
```

```
91.08f64
```



==
entry: parse_header
script input { $loadbytes "../data/t10k-images-idx3-ubyte" }
output {  2051i64 10000i64 28i64 28i64  }
script input { $loadbytes "../data/t10k-labels-idx1-ubyte" }
output {  2049i64 10000i64 117571840i64 67175433i64 }
